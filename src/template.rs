/*
 -------------------------------------------------------------------------------
    This file is part of the Corona numbers website generator.
    Copyright (C) 2020  Dirk Stolle
    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
 -------------------------------------------------------------------------------
*/

mod html;

use std::collections::HashMap;
use std::path::Path;

const TAG_OPENER: &str = "{{";
const TAG_CLOSER: &str = "}}";
const INTEGRATE_OPENER: &str = "{{>";
const INTEGRATE_CLOSER: &str = "}}";

pub struct Template
{
  sections: HashMap<String, String>,
  tags: HashMap<String, String>,
  includes: HashMap<String, String>,
  template: Option<String>
}

impl Template
{
  /**
   * Creates a new, empty template instance.
   */
  pub fn new() -> Template
  {
    Template
    {
      sections: HashMap::new(),
      tags: HashMap::new(),
      includes: HashMap::new(),
      template: None
    }
  }

  /**
   * Loads template from a file.
   *
   * @param file_name  name of the file to load
   * @return true, if template was loaded successfully; false otherwise
   */
  pub fn from_file(&mut self, file_name: &str) -> bool
  {
    let path = Path::new(file_name);
    if !path.is_file() || !path.exists()
    {
      return false;
    }
    let content = match std::fs::read_to_string(path)
    {
      Err(_) => return false,
      Ok(s) => s
    };
    if content.trim() == ""
    {
      return false;
    }

    let pattern = "<!--section-start::(.*?)-->(.*?)<!--section-end::(.*?)-->";
    // Use regular expression builder with pattern above.
    let re = regex::RegexBuilder::new(pattern)
      // Dots also need to match new lines for template data.
      .dot_matches_new_line(true)
      // Build it and unwrap it, because it does not error out with proper pattern.
      .build()
      .unwrap();
    if re.captures_len() == 0
    {
      return false;
    }
    self.sections.clear();
    for cap in re.captures_iter(&content)
    {
      if cap[1] != cap[3]
      {
        // Section start and end names do not match!
        continue;
      }
      self.sections.insert(cap[1].to_string(), cap[2].to_string());
    }

    // Clear previously set tags and template, because they are not really valid
    // anymore.
    self.tags.clear();
    self.includes.clear();
    self.template = None;
    !self.sections.is_empty()
  }

  /**
   * Loads a section of the template.
   *
   * @param section_name  name of the section to load
   * @return true if section was loaded, false otherwise
   */
  pub fn load_section(&mut self, section_name: &str) -> bool
  {
    return match self.sections.get(section_name)
    {
      None =>
      {
        eprintln!("There is no section '{}'.", section_name);
        eprintln!("sections: {:?}", self.sections.keys());
        false
      },
      Some(content) => {
        self.template = Some(content.to_string());
        true
      }
    }
  }

  /**
   * Sets the replacements text for a tag.
   * HTML entities in replacement are escaped during template generation.
   * Therefore it can also be used to show raw user input safely.
   *
   * @param name  name of the tag to replace
   * @param replacement the replacement
   */
  pub fn tag(&mut self, name: &str, replacement: &str)
  {
    self.tags.insert(String::from(name), String::from(replacement));
  }

  /**
   * Sets the replacements text for an included template.
   * HTML entities in replacement are NOT escaped during template generation.
   * Therefore include() is suitable to include stuff generated by other
   * templates, since any HTML is preserved. However, it is NOT suitable to
   * include raw user input.
   *
   * @param name  name of the template to include
   * @param replacement the replacement
   */
  pub fn integrate(&mut self, name: &str, replacement: &str)
  {
    self.includes.insert(String::from(name), String::from(replacement));
  }

  /**
   * Generates the final template, ready for display.
   *
   * @return the template with all replacement values filled
   */
  pub fn generate(&self) -> Option<String>
  {
    let mut out = match &self.template
    {
      None => return None,
      Some(val) => val.clone()
    };
    for (tag_name, tag_value) in self.tags.iter()
    {
      let find = String::from(TAG_OPENER) + &tag_name + TAG_CLOSER;
      out = out.replace(&find, &html::special_chars(&tag_value));
    }
    for (inc_name, inc_value) in self.includes.iter()
    {
      let find: String = String::from(INTEGRATE_OPENER) + &inc_name + INTEGRATE_CLOSER;
      out = out.replace(&find, &inc_value);
    }
    Some(out)
  }
}

#[cfg(test)]
mod tests
{
  use super::*;
  use std::env;
  use std::fs;

  #[test]
  fn new_is_empty()
  {
    let tpl = Template::new();

    assert!(tpl.sections.is_empty());
    assert!(tpl.tags.is_empty());
    assert!(tpl.includes.is_empty());
    assert!(tpl.template.is_none());
  }

  #[test]
  fn tag()
  {
    let mut tpl = Template::new();

    tpl.tag("foo", "bar");
    assert!(tpl.tags.contains_key("foo"));
    assert!(!tpl.tags.contains_key("bar"));
    assert_eq!(Some(&String::from("bar")), tpl.tags.get("foo"));
  }

  #[test]
  fn integrate()
  {
    let mut tpl = Template::new();

    tpl.integrate("foo", "<b>bar</b>");
    assert!(tpl.includes.contains_key("foo"));
    assert!(!tpl.includes.contains_key("<b>bar</b>"));
    assert_eq!(Some(&String::from("<b>bar</b>")), tpl.includes.get("foo"));
  }

  #[test]
  fn from_file_single_section()
  {
    let path = env::temp_dir().join("from_file_single_section.tpl");
    let simple_template =
      "<!--section-start::test--><li><a href=\"{{url}}\">{{text}}</a></li><!--section-end::test-->";
    fs::write(&path, simple_template).expect("Unable to write template file for test!");
    let path = path.to_str().unwrap();

    let mut tpl = Template::new();
    assert!(tpl.from_file(path));
    assert_eq!(1, tpl.sections.len());
    assert!(tpl.sections.contains_key("test"));
    assert_eq!(Some(&String::from("<li><a href=\"{{url}}\">{{text}}</a></li>")), tpl.sections.get("test"));

    fs::remove_file(path).expect("Unable to delete template file!");
  }

  #[test]
  fn from_file_newlines()
  {
    let path = env::temp_dir().join("from_file_newlines.tpl");
    let simple_template = "<!--section-start::test--><li>\n  <a href=\"{{url}}\">{{text}}</a>\r\n</li><!--section-end::test-->";
    fs::write(&path, simple_template).expect("Unable to write template file for test!");
    let path = path.to_str().unwrap();

    let mut tpl = Template::new();
    assert!(tpl.from_file(path));
    assert_eq!(1, tpl.sections.len());
    assert!(tpl.sections.contains_key("test"));
    assert_eq!(Some(&String::from("<li>\n  <a href=\"{{url}}\">{{text}}</a>\r\n</li>")), tpl.sections.get("test"));

    fs::remove_file(path).expect("Unable to delete template file!");
  }

  #[test]
  fn from_file_multiple_sections()
  {
    let path = env::temp_dir().join("from_file_multiple_sections.tpl");
    let simple_template = "<!--section-start::test--><a href=\"{{url}}\">{{text}}</a><!--section-end::test-->\n<!--section-start::foo--><b>Info:</b> {{info}}<!--section-end::foo-->";
    fs::write(&path, simple_template).expect("Unable to write template file for test!");
    let path = path.to_str().unwrap();

    let mut tpl = Template::new();
    assert!(tpl.from_file(path));

    assert_eq!(2, tpl.sections.len());
    assert!(tpl.sections.contains_key("test"));
    assert_eq!(Some(&String::from("<a href=\"{{url}}\">{{text}}</a>")), tpl.sections.get("test"));
    assert!(tpl.sections.contains_key("foo"));
    assert_eq!(Some(&String::from("<b>Info:</b> {{info}}")), tpl.sections.get("foo"));

    fs::remove_file(path).expect("Unable to delete template file!");
  }

  #[test]
  fn from_file_multiple_sections_newlines()
  {
    let path = env::temp_dir().join("from_file_multiple_sections_newlines.tpl");
    let simple_template = "<!--section-start::test--><li>\n  <a href=\"{{url}}\">{{text}}</a>\r\n</li><!--section-end::test-->\n<!--section-start::foo--><b>Info\nFoo\r\nBar\rBaz:</b> {{info}}<!--section-end::foo-->";
    fs::write(&path, simple_template).expect("Unable to write template file for test!");
    let path = path.to_str().unwrap();

    let mut tpl = Template::new();
    assert!(tpl.from_file(path));

    assert_eq!(2, tpl.sections.len());
    assert!(tpl.sections.contains_key("test"));
    assert_eq!(Some(&String::from("<li>\n  <a href=\"{{url}}\">{{text}}</a>\r\n</li>")), tpl.sections.get("test"));
    assert!(tpl.sections.contains_key("foo"));
    assert_eq!(Some(&String::from("<b>Info\nFoo\r\nBar\rBaz:</b> {{info}}")), tpl.sections.get("foo"));

    fs::remove_file(path).expect("Unable to delete template file!");
  }

  #[test]
  fn load_section()
  {
    let path = env::temp_dir().join("load_section.tpl");
    let simple_template =
      "<!--section-start::test--><a href=\"{{url}}\">{{text}}</a><!--section-end::test-->";
    fs::write(&path, simple_template).expect("Unable to write template file for test!");
    let path = path.to_str().unwrap();

    let mut tpl = Template::new();
    assert!(tpl.from_file(path));

    // Section "test" should load just fine.
    assert!(tpl.load_section("test"));
    assert_eq!(Some(String::from("<a href=\"{{url}}\">{{text}}</a>")), tpl.template);
    // Section "something_else" does not exist, it should not be loaded.
    assert!(!tpl.load_section("something_else"));

    fs::remove_file(path).expect("Unable to delete template file!");
  }

  #[test]
  fn generate_simple()
  {
    let path = env::temp_dir().join("generate_simple.tpl");
    let simple_template =
      "<!--section-start::test--><a href=\"{{url}}\">{{text}}</a><!--section-end::test-->";
    fs::write(&path, simple_template).expect("Unable to write template file for test!");
    let path = path.to_str().unwrap();

    let mut tpl = Template::new();
    assert!(tpl.from_file(path));
    assert!(tpl.load_section("test"));
    tpl.tag("url", "http://localhost/");
    tpl.tag("text", "home");

    assert_eq!(Some(String::from("<a href=\"http://localhost/\">home</a>")), tpl.generate());

    fs::remove_file(path).expect("Unable to delete template file!");
  }

  #[test]
  fn generate_special_characters()
  {
    let path = env::temp_dir().join("generate_special_characters.tpl");
    let simple_template =
      "<!--section-start::test--><a href=\"{{url}}\">{{text}}</a><!--section-end::test-->";
    fs::write(&path, simple_template).expect("Unable to write template file for test!");
    let path = path.to_str().unwrap();

    let mut tpl = Template::new();
    assert!(tpl.from_file(path));
    assert!(tpl.load_section("test"));
    tpl.tag("url", "http://localhost/");
    tpl.tag("text", "<< foo & 'bar' >>");

    // Text should be escaped properly.
    assert_eq!(
      Some(String::from("<a href=\"http://localhost/\">&lt;&lt; foo &amp; &#39;bar&#39; &gt;&gt;</a>")),
      tpl.generate());

    fs::remove_file(path).expect("Unable to delete template file!");
  }
}
