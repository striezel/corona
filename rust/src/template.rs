/*
 -------------------------------------------------------------------------------
    This file is part of the Corona numbers website generator.
    Copyright (C) 2020  Dirk Stolle
    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
 -------------------------------------------------------------------------------
*/

use std::collections::HashMap;
use std::env;
use std::fs;
use std::path::Path;

use regex::Regex;

const TAG_OPENER: &str = "{{";
const TAG_CLOSER: &str = "}}";
const INTEGRATE_OPENER: &str = "{{>";
const INTEGRATE_CLOSER: &str = "}}";

pub struct Template
{
  sections: HashMap<String, String>,
  tags: HashMap<String, String>,
  includes: HashMap<String, String>,
  template: Option<String>
}

impl Template
{
  /**
   * Creates a new, empty template instance.
   */
  pub fn new() -> Template
  {
    Template
    {
      sections: HashMap::new(),
      tags: HashMap::new(),
      includes: HashMap::new(),
      template: None
    }
  }

  /**
   * Loads template from a file.
   *
   * @param file_name  name of the file to load
   * @return true, if template was loaded successfully; false otherwise
   */
  pub fn from_file(&mut self, file_name: &str) -> bool
  {
    let path = Path::new(file_name);
    if !path.is_file() || !path.exists()
    {
      return false;
    }
    let content = match std::fs::read_to_string(path)
    {
      Err(_) => return false,
      Ok(s) => s
    };
    if content.trim() == ""
    {
      return false;
    }

    let pattern = "<!--section-start::(.*)-->(.*)<!--section-end::(.*)-->";
    let re = regex::Regex::new(pattern).unwrap();
    if re.captures_len() == 0
    {
      eprintln!("No match / captures found!");
      return false;
    }
    self.sections.clear();
    for cap in re.captures_iter(&content)
    {
      if cap[1].to_string() != cap[3].to_string()
      {
        // Section start and end names do not match!
        self.sections.clear();
        return false;
      }
      self.sections.insert(cap[1].to_string(), cap[2].to_string());
    }

    // Clear previously set tags and template, because they are not really valid
    // anymore.
    self.tags.clear();
    self.includes.clear();
    self.template = None;
    return !self.sections.is_empty();
  }

  /**
   * Loads a section of the template.
   *
   * @param section_name  name of the section to load
   * @return true if section was loaded, false otherwise
   */
  pub fn load_section(&mut self, section_name: &str) -> bool
  {
    return match self.sections.get(section_name)
    {
      None => {
        eprintln!("There is no section '{}'.", section_name);
        eprintln!("sections: {:?}", self.sections.keys());
        false
      },
      Some(content) => {
        self.template = Some(content.to_string());
        true
      }
    }
  }

  /**
   * Sets the replacements text for a tag.
   * HTML entities in replacement are escaped during template generation.
   * Therefore it can also be used to show raw user input safely.
   *
   * @param name  name of the tag to replace
   * @param replacement the replacement
   */
  pub fn tag(&mut self, name: &str, replacement: &str)
  {
    self.tags.insert(String::from(name), String::from(replacement));
  }

  /**
   * Sets the replacements text for an included template.
   * HTML entities in replacement are NOT escaped during template generation.
   * Therefore include() is suitable to include stuff generated by other
   * templates, since any HTML is preserved. However, it is NOT suitable to
   * include raw user input.
   *
   * @param name  name of the template to include
   * @param replacement the replacement
   */
  pub fn integrate(&mut self, name: &str, replacement: &str)
  {
    self.includes.insert(String::from(name), String::from(replacement));
  }

  /**
   * Generates the final template, ready for display.
   *
   * @return the template with all replacement values filled
   */
  pub fn generate(&self) -> Option<String>
  {
    let mut out = match &self.template
    {
      None => return None,
      Some(val) => val.clone()
    };
    for (tag_name, tag_value) in self.tags.iter()
    {
      let find = String::from(TAG_OPENER) + &tag_name + TAG_CLOSER;
      // TODO: Escape HTML entities and special characters!
      // FIXME: Introduce proper HTML escaping like in PHP's htmlentities().
      out = out.replace(&find, &tag_value);
    }
    for (inc_name, inc_value) in self.includes.iter()
    {
      let find: String = String::from(INTEGRATE_OPENER) + &inc_name + INTEGRATE_CLOSER;
      out = out.replace(&find, &inc_value);
    }
    Some(out)
  }
}

#[cfg(test)]
mod tests {
  use super::*;

  #[test]
  fn new_is_empty()
  {
    let tpl = Template::new();

    assert!(tpl.sections.is_empty());
    assert!(tpl.tags.is_empty());
    assert!(tpl.includes.is_empty());
    assert!(tpl.template.is_none());
  }

  #[test]
  fn tag()
  {
    let mut tpl = Template::new();

    tpl.tag("foo", "bar");
    assert!(tpl.tags.contains_key("foo"));
    assert!(!tpl.tags.contains_key("bar"));
    assert_eq!(Some(&String::from("bar")), tpl.tags.get("foo"));
  }

  #[test]
  fn integrate()
  {
    let mut tpl = Template::new();

    tpl.integrate("foo", "<b>bar</b>");
    assert!(tpl.includes.contains_key("foo"));
    assert!(!tpl.includes.contains_key("<b>bar</b>"));
    assert_eq!(Some(&String::from("<b>bar</b>")), tpl.includes.get("foo"));
  }

  #[test]
  fn from_file()
  {
    let path = env::temp_dir().join("foo_1.tpl");
    let simple_template = "<!--section-start::test--><li><a href=\"{{url}}\">{{text}}</a></li><!--section-end::test-->";
    fs::write(&path, simple_template).expect("Unable to write template file for test!");
    let path = path.to_str().unwrap();

    let mut tpl = Template::new();
    assert!(tpl.from_file(path));

    fs::remove_file(path).expect("Unable to delete template file!");
  }

  #[test]
  fn load_section()
  {
    let path = env::temp_dir().join("foo_2.tpl");
    let simple_template = "<!--section-start::test--><a href=\"{{url}}\">{{text}}</a><!--section-end::test-->";
    fs::write(&path, simple_template).expect("Unable to write template file for test!");
    let path = path.to_str().unwrap();

    let mut tpl = Template::new();
    assert!(tpl.from_file(path));

    // Section "test" should load just fine.
    assert!(tpl.load_section("test"));
    assert_eq!(Some(String::from("<a href=\"{{url}}\">{{text}}</a>")), tpl.template);
    // Section "something_else" does not exist, it should not be loaded.
    assert!(!tpl.load_section("something_else"));

    fs::remove_file(path).expect("Unable to delete template file!");
  }

  #[test]
  fn generate_simple()
  {
    let path = env::temp_dir().join("foo_3.tpl");
    let simple_template = "<!--section-start::test--><a href=\"{{url}}\">{{text}}</a><!--section-end::test-->";
    fs::write(&path, simple_template).expect("Unable to write template file for test!");
    let path = path.to_str().unwrap();

    let mut tpl = Template::new();
    assert!(tpl.from_file(path));
    assert!(tpl.load_section("test"));
    tpl.tag("url", "http://localhost/");
    tpl.tag("text", "home");

    assert_eq!(Some(String::from("<a href=\"http://localhost/\">home</a>")), tpl.generate());

    fs::remove_file(path).expect("Unable to delete template file!");
  }
}
